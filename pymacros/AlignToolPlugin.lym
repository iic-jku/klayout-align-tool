<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># --------------------------------------------------------------------------------
# SPDX-FileCopyrightText: 2025 Martin Jan Köhler
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
# SPDX-License-Identifier: GPL-3.0-or-later
#--------------------------------------------------------------------------------


from dataclasses import dataclass
from typing import *
import os 
from enum import StrEnum
import pya


DEBUG = False


def debug(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)


class AlignToolState(StrEnum):
    INACTIVE = "inactive"
    PENDING_SELECTION1 = "pending_selection1"
    PENDING_SELECTION2 = "pending_selection2"


@dataclass
class AlignToolSelection:
    edge: Optional[pya.Edge]
    path: List[pya.InstElement]
    shape: Optional[pya.Shape]
    bbox_of_instance: Optional[pya.Instance]
    layer: Optional[int]
    snap_point: Optional[pya.Point]


class AlignToolSetupDock(pya.QDockWidget):
    def __init__(self):
        super().__init__()
        self.setupWidget = AlignToolSetupWidget()
        self.setWidget(self.setupWidget)
        self.setWindowTitle("Align Tool")
        
    def updateState(self, state: AlignToolState):
        self.setupWidget.updateState(state)
        
        
class AlignToolSetupWidget(pya.QWidget):
    def __init__(self):
        super().__init__()
        self.statusLabel = pya.QLabel("Status: initalizing…")
        self.cancelInfoLabel = pya.QLabel("Esc to cancel")
        self.cancelInfoLabel.foregroundRole = pya.QPalette_ColorRole.Mid
        
        self.layout       = pya.QGridLayout()
        self.layout.addWidget(self.statusLabel,    0, 0, 1, 1)
        self.layout.addWidget(self.cancelInfoLabel,    1, 0, 1, 1)
        self.layout.setRowStretch(2, 1)
        self.setLayout(self.layout)
         
    def hideEvent(self, event):
        event.accept()

    def updateState(self, state: AlignToolState):
        msg: str = ""
        match state:
            case AlignToolState.INACTIVE:
                msg = ""
            case AlignToolState.PENDING_SELECTION1:
                msg = "Next: Select point to align"
            case AlignToolState.PENDING_SELECTION2:
                msg = "Next: Select point to reference"
        self.statusLabel.setText(msg)

        
class AlignToolPlugin(pya.Plugin):
    def __init__(self, view: pya.LayoutView):
        super().__init__()
        self.setupDock      = None
        self.view            = view

        self._state = AlignToolState.INACTIVE
        self._selection1: Optional[AlignToolSelection] = None
        self.markers_selection1 = []
        self.markers_selection2 = []
        self.toolTip = pya.QToolTip()       

    @property
    def cell_view(self) -&gt; pya.CellView:
        return self.view.active_cellview()

    @property
    def layout(self) -&gt; pya.Layout:
        return self.cell_view.layout()
        
    @property
    def dbu(self) -&gt; float:
        return self.layout.dbu

    @property
    def state(self) -&gt; AlignToolState:
        return self._state

    @state.setter
    def state(self, state: AlignToolState):
        debug(f"Transitioning from {self._state.value} to {state.value}")
        self._state = state
        if not(self.setupDock):
            pass
        else:
            self.setupDock.updateState(state)

    @property
    def selection1(self) -&gt; AlignToolSelection:
        return self._selection1

    @selection1.setter
    def selection1(self, selection: AlignToolSelection):
        debug(f"setting selection1 to {selection}")
        self._selection1 = selection

    def activated(self):
        debug("AlignToolPlugin.activated")

        if not(self.setupDock):
            mw   = pya.Application.instance().main_window()
            self.setupDock = AlignToolSetupDock()
            mw.addDockWidget(pya.Qt_DockWidgetArea.RightDockWidgetArea, self.setupDock)
        self.setupDock.show()
        
        self.state = AlignToolState.PENDING_SELECTION1
            
    def deactivated(self):
        debug("AlignToolPlugin.deactivated")
        
        self.state = AlignToolState.INACTIVE
        
        self._clear_all_markers()
        self.ungrab_mouse()
        if self.setupDock:
            self.setupDock.hide()

    def deactivate(self):
        debug("AlignToolPlugin.deactive")
        esc_key  = 16777216 
        keyPress = pya.QKeyEvent(pya.QKeyEvent.KeyPress, esc_key, pya.Qt.NoModifier)
        pya.QApplication.sendEvent(self.view.widget(), keyPress)        

    def _clear_all_markers(self):
        self._clear_markers_selection1()
        self._clear_markers_selection2()
        
    def _clear_markers_selection1(self):
        for marker in self.markers_selection1:
            marker._destroy()
        self.markers_selection1 = []
    
    def _clear_markers_selection2(self):
        for marker in self.markers_selection2:
            marker._destroy()
        self.markers_selection2 = []
    
    def find_nearest_edge_point(self, location: pya.Point, edge: pya.Edge) -&gt; pya.Point:
        """
        On the chosen edge, we want to find nearest end point or the center point
        """

        def halfway(a: int, b:int) -&gt; int:
            if a &lt; b:
                return a + (b - a) / 2
            else:
                return b + (a - b) / 2

        nearest_point = None
        nearest_distance = 9999999999
        
        edge_center = pya.Point(halfway(edge.x1, edge.x2), halfway(edge.y1, edge.y2))
        points = [edge_center, edge.p1, edge.p2]
        distances = [abs(p.distance(location)) for p in points]
        
        for point, distance in zip(points, distances):
            if distance &lt; nearest_distance:
                nearest_distance = distance
                nearest_point = point  
        
        return nearest_point
    
    def visible_layer_indexes(self) -&gt; List[int]:
        idxs = []
        for lref in self.view.each_layer():
            if lref.visible and lref.valid:
                if lref.layer_index() == -1:  # hidden by the user
                    continue
                # print(f"layer is visible, name={lref.name}, idx={lref.layer_index()}, "
                #       f"marked={lref.marked} cellview={lref.cellview()}, "
                #      f"source={lref.source}")
                idxs.append(lref.layer_index())
        return idxs
    
    def find_selection(self, location: pya.DPoint, max_distance: int) -&gt; Optional[AlignToolSelection]:
        location = location.to_itype(self.dbu)
        
        nearest = AlignToolSelection(edge=None,
                                     path=[],    
                                     shape=None,
                                     bbox_of_instance=None,
                                     layer=None,
                                     snap_point=None)
        
        def consider_edge_selection(selection: AlignToolSelection):
            nonlocal nearest, search_box
            intersection = e.clipped_line(search_box)
            if intersection is None:
                return
            if nearest.edge is None or \
               selection.edge.distance_abs(location) &lt; nearest.edge.distance_abs(location):
                nearest = selection
        
        search_box = pya.Box(location.x - max_distance, location.y - max_distance, 
                             location.x + max_distance, location.y + max_distance)
        
        visible_layer_indexes = self.visible_layer_indexes()
        
        for top_cell in self.layout.top_cells():
            if self.cell_view.is_cell_hidden(top_cell):
                continue
            
            # we prioritize the child instances of top cell
            # for those we also consider the bounding box
            for inst in top_cell.each_inst():
                hidden = self.view.is_cell_hidden(inst.cell.cell_index(), self.view.active_cellview_index)
                # print(f"inst from cell {inst.cell.name} hidden? {is_hidden}")
                if not hidden:
                    edges = pya.Edges(inst.bbox())
                    for e in edges:
                        consider_edge_selection(
                            AlignToolSelection(edge=e,
                                               path=[],
                                               shape=inst.bbox(),
                                               bbox_of_instance=inst,
                                               layer=None,
                                               snap_point=None)  # NOTE: snap point will be set later
                        )
            
            # for lyr, li in enumerate(self.layout.layer_infos()):
            for lyr in visible_layer_indexes:
                iter = top_cell.begin_shapes_rec_overlapping(lyr, search_box)
                iter.min_depth = self.view.min_hier_levels
                iter.max_depth = max(self.view.max_hier_levels-1, 0)
                
                while not iter.at_end():
                    sh = iter.shape()
                    # print(f"lyr {lyr} ({li}), found {sh}")
                    pg = sh.polygon
                    if pg is None:
                        print(f"Skip shape {sh}, it's has no polygon")
                    else:
                        p = sh.polygon.transformed(iter.itrans())
                        for e in p.each_edge():
                            consider_edge_selection(
                                AlignToolSelection(edge=e,
                                                   path=iter.path(),
                                                   shape=sh,
                                                   bbox_of_instance=None,
                                                   layer=lyr,
                                                   snap_point=None)  # NOTE: snap point will be set later
                            )
                    iter.next()

        if nearest.edge is None:
            return None
            
        nearest.snap_point = self.find_nearest_edge_point(location=location, edge=nearest.edge)
        return nearest
    
    @property
    def max_distance(self) -&gt; int:
        return 20
    
    def preview_markers_for_selection(self, selection: AlignToolSelection) -&gt; List[pya.Marker]:
        edge_marker = pya.Marker(self.view)
        edge_marker.line_style     = 0
        edge_marker.line_width     = 1
        edge_marker.vertex_size    = 4 
        edge_marker.dither_pattern = 2
        edge_marker.set(selection.edge.to_dtype(self.dbu))
        
        point_marker = pya.Marker(self.view)
        point_marker.line_style     = 0
        point_marker.line_width     = 1
        point_marker.vertex_size    = 4
        point_marker.dither_pattern = 2
        d = 10
        marker_box = pya.Box(pya.Point(selection.snap_point.x - d, selection.snap_point.y - d), 
                             pya.Point(selection.snap_point.x + d, selection.snap_point.y + d))
        point_marker.set(marker_box.to_dtype(self.dbu))
        
        return [edge_marker, point_marker]
    
    def mouse_moved_event(self, dpoint: pya.DPoint, buttons: int, prio: bool):
        if prio:
            # print(f"mouse moved event, p={dpoint}, prio={prio}")

            selection = self.find_selection(location=dpoint, max_distance=self.max_distance)
            if selection is None:
                match self.state:
                    case AlignToolState.INACTIVE:
                        return False
                    case AlignToolState.PENDING_SELECTION1:
                        self.toolTip.showText(pya.QCursor.pos, "Select shape feature to align") 
                    case AlignToolState.PENDING_SELECTION2:
                        self.toolTip.showText(pya.QCursor.pos, "Select shape feature to reference") 
                return False  
            
            match self.state:
                case AlignToolState.INACTIVE:
                    return False
                 
                case AlignToolState.PENDING_SELECTION1:
                    self._clear_markers_selection1()
                    self.markers_selection1 = self.preview_markers_for_selection(selection)

                case AlignToolState.PENDING_SELECTION2:
                    self._clear_markers_selection2()
                    self.markers_selection2 = self.preview_markers_for_selection(selection)

            return True           
        return False
        
    def mouse_click_event(self, dpoint: pya.DPoint, buttons: int, prio: bool):
        if prio:
            if buttons in [8]:  # Left click
                selection = self.find_selection(location=dpoint, max_distance=self.max_distance)
                if selection is None:
                    return False
                    
                match self.state:
                    case AlignToolState.INACTIVE:
                        return False
                     
                    case AlignToolState.PENDING_SELECTION1:
                        self.selection1 = selection
                        self.state = AlignToolState.PENDING_SELECTION2
                        
                    case AlignToolState.PENDING_SELECTION2:
                        selection1 = self.selection1
                        selection2 = selection
                    
                        self.state = AlignToolState.INACTIVE
                        self.selection1 = None
                        
                        self.commit_align(selection1, selection2)
                
            if buttons in [16, 32]:
                self._clear_markers()
                
            return True
        return False
        
    def commit_align(self, selection1: AlignToolSelection, selection2: AlignToolSelection):
        self.view.transaction("align")
        try:
            if len(selection1.path) == 0:  # a shape within the same cell has to be aligned
                if selection1.bbox_of_instance is None:
                    debug(f"COMMIT, "
                          f"\n\tshape {selection1.shape} is aligned to "
                          f"\n\t{selection2.snap_point}")
                    trans = pya.Trans(selection2.snap_point.x - selection1.snap_point.x,
                                      selection2.snap_point.y - selection1.snap_point.y)
                    selection1.shape.transform(trans)
                else:  # bounding box of an instance
                    inst1 = selection1.bbox_of_instance
                    debug(f"COMMIT, "
                          f"\n\tinstance {inst1} is aligned to "
                          f"\n\t{selection2.snap_point}")
                    trans = pya.Trans(selection2.snap_point.x - selection1.snap_point.x,
                                      selection2.snap_point.y - selection1.snap_point.y)
                    inst1.transform(trans)
            elif len(selection1.path) &gt;= 1:  # an instance has to be aligned
                inst1 = selection1.path[0]
                debug(f"COMMIT, "
                      f"\n\tinstance {inst1} is aligned to "
                      f"\n\t{selection2.snap_point}")
                trans = pya.Trans(selection2.snap_point.x - selection1.snap_point.x,
                                  selection2.snap_point.y - selection1.snap_point.y)
                inst1.inst().transform(trans)
            
        finally:
            self.view.commit()
            self.deactivate()


class AlignToolPluginFactory(pya.PluginFactory):
    def __init__(self):
        super().__init__()
        iconPath = os.path.join(os.path.dirname(__file__), 'AlignToolIcon', '%s.png')
        self.register(-1000, "Align Tool", "Align Tool", iconPath % "icon")
  
    def create_plugin(self, manager, root, view):
        return AlignToolPlugin(view)

AlignToolPluginFactory.instance = AlignToolPluginFactory()
</text>
</klayout-macro>
